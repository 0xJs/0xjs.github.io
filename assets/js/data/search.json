[ { "title": "CESP review", "url": "/posts/CESP-review/", "categories": "Ethical Hacking, Reviews", "tags": "ethical hacking, red teaming", "date": "2023-08-24 15:30:00 +0200", "snippet": "IntroductionAltered Security released the new course Certified Enterprise Security Professional – AD CS (CESP). This course is pureply focussed on Active Directory Certificate Services (ADCS). It is required to have basic Active Directory(AD) knowledge before starting the course (CRTP level). I have a decent amount of knowledge about AD, but I never played with ADCS and my knowledge was limited on it. I never fully read the famous ADCS Certified Pre-Owned whitepaper by SpecterOps.The course basiscly covers everything from the paper that still works since Microsoft patched a couple of attacks and it covers some extra certificate stuff.The material &amp;amp; courseThe course focusses on ADCS and will teach you everything about; how to escalate privileges locally using CertPotato how to escalate privileges abusing certificate templates - ESCx attacks how to steal certificates - THEFTx attacks how to build persistence with certificates - (D)PERSTISTx attacks how to sign your own executables with stolen signing certificates bypassing WDAC policies how to forge a certificate to authenticate to Azure using a stolen Certificate AuthorityThe course costs starts at 250 euros for a month access including an exam attempt. A full curriculum can be found here. All the new thing I learned will be added to my RedTeaming CheatSheet soon.The labsThe labs and the material go hand in hand and will guide you through the attack paths inside the lab. The lab exists out of three forests and an Azure tenant.The lab starts from the ‘‘Assume Breach’’ perspective which means you are given valid AD credentials and access to a machine to perform the attacks from. All tools required are already installed on the machine and there also is WSL to perform the attacks from the Linux perspective.There are two options to connect to the lab. One is using the VPN pack and RDP into the machine and the other is using Apache Guacamole web access. The first option was very stable for me, I didn’t try the web access since I dislike Apache Guacamole. The machines in the run 24/7 and it is a shared environment with other students. This has it benefits such as you can keep Terminals open and keep continuing after leaving the pc for a while or after reconnecting the next day. But from time to time you mind stumble upon another student their tools on a machine.The lab for me was very stable, the material and lab manual are very good and can be followed easily. The total video material is a bit longer then 11 hours with 223 slides and the lab manual is 206 pages long. The lab and material is categorized in objectives(exercises) which the student needs to do. In the lab portal there are two questions(flags/info to be collected) which need to be be answered for each objective.The only thing I disliked about the course is the way the video material is categorized since it isn’t fully in sync with the slides. The video’s aren’t ordered correctly, the video about how to complete the objective using Linux or Windows is before the video which explains the theory behind the attack. Which got me confused quite a bit sometimes.The examThe exam environment exists out of 4 machines excluding the starting machine and the goal of the exam is to get code execution on all of em. Once the exam starts you are given 25 hours to compromise the environment and then 48 hours to write the report. The exam environment has the same connectivity options as in the lab, either VPN or Apache Guacamole via the browser.My exam experienceI started the exam around 9:30 AM and had access to all machines around 12:30 AM, so there is plenty of time for the exam. I went through it quickly but it would take someone a bit more time I would guess. The exam is quite easy, just above CRTP level and doesn’t contain new techniques not taught in the course.ConclusionI really liked the course and the lab. It is another great course teached by Nikhil from Altered Security." }, { "title": "Identifying highly privileged identities and checking MFA status", "url": "/posts/Identifying-highly-privileged-identities-and-checking-MFA-status/", "categories": "Ethical Hacking, Azure", "tags": "ethical hacking, azure", "date": "2022-12-18 20:35:00 +0100", "snippet": "IntroductionThis is the fourth blog in the series. If you haven’t read the previous blog you can find it here. In the previous blogs we discussed the different types of identities and how we can find high privileged identities. In those blogs PowerShell cmdlets were created which helped querying these different types of identities. In this blog everything will be tied together into one cmdlet and we will have a look at MFA.A quick recap of what we have learned in the previous blogposts: Roles can be assigned these three identities and these identities: Users Groups Can’t have nested groups when assigned to roles. Can have owners (Users or service principals) ServicePrincipals Can have Owners (Users) Can have permissions Identifying highly privileged identitiesMicrosoft define these 14 roles highly privileged. So to get a overview of all the highly privileged identities in the Azure Tenant we should query the following using the created cmdlets:1 Users, we can query this with: Get-AzureADPrivilegedRolesMembersGet-AzureADPrivilegedRolesMembersObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------766787e8-82c1-4062-bfa9-5d4a4ca300f3 0xjs 0xjs@jonyschats.nl Membereb815e66-31a5-45ca-bed8-2b0f5e24f62f GroupUser GroupUser@jonyschats.nl Member2 Privileged group owners, we can query this with Get-AzureADPrivilegedRolesMembers -ReturnGroup | Get-AzureADGroupOwner.Get-AzureADPrivilegedRolesMembers -ReturnGroup | Get-AzureADGroupOwnerObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------2cc999ae-fe8e-4ce9-a18a-309d68f5bce2 GroupOwnerUser GroupOwnerUser@jonyschats.nl Member3 Privileged service principals, we can query this with Get-AzureADPrivilegedRolesMembers -ReturnServicePrincipals Get-AzureADPrivilegedRolesMembers -ReturnServicePrincipalsObjectId AppId DisplayName-------- ----- -----------5530a9cf-a45a-4662-9179-eaa8d9089605 1a93dd32-5ade-4656-9ada-6a285676eb92 Test_enterpriseapp4 Privileged service principal owners, we can query this with Get-AzureADPrivilegedRolesMembers -ReturnServicePrincipals | Get-AzureADServicePrincipalOwnerGet-AzureADPrivilegedRolesMembers -ReturnServicePrincipals | Get-AzureADServicePrincipalOwnerObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------59b28e90-d96b-410b-acc6-fa9ee823bfbd ServicePrincipalOwner ServicePrincipalOwner@jonyschats.nl Member5 Service principals with permissions configured/consented. Well… that is something for a whole new blog.Since nobody likes to run multiple commands I created another PowerShell cmdlet, which is Get-AzureADPrivilegedIdentities. This cmdlet queries this information and gathers the user and service principal objects and returns them:Function Get-AzureADPrivilegedIdentities{&amp;lt;#.SYNOPSISAuthor: Jony Schats - 0xjsRequired Dependencies: Get-AzureADPrivilegedRolesMembers, Get-AzureADDirectoryRole, Get-AzureADDirectoryRoleMember, Get-AzureADGroupMember, Get-AzureADGroupMemberRecursiveOptional Dependencies: None.DESCRIPTIONRecursively search through privileged roles and return users and service principal identities and their owners.EXAMPLEGet-AzureADPrivilegedIdentities#&amp;gt; [cmdletbinding()] param( ) Begin{ # Check if Azure AD is loaded If(-not(Get-Command *Get-AzureADCurrentSessionInfo*)){ Write-Host -ForegroundColor Red &quot;AzureAD Module not imported, stopping&quot; break } # Check connection with AzureAD try { $var = Get-AzureADTenantDetail } catch { Write-Host -ForegroundColor Red &quot;You&#39;re not connected with AzureAD, Connect with Connect-AzureAD&quot; break } $AllUsers = @() $AllServicePrincipals = @() $Output = @() } Process { # Retrieving privileged users member of role $Users = Get-AzureADPrivilegedRolesMembers $AllUsers += $users $UsersCount = ($Users | Measure-Object).count Write-Host &quot;[+] Discovered $UsersCount users&quot; # Retrieving privileged group owners $GroupOwners = Get-AzureADPrivilegedRolesMembers -ReturnGroup | Get-AzureADGroupOwner $AllUsers += $GroupOwners | Where-Object -Property ObjectType -Match User $AllServicePrincipals += $GroupOwners | Where-Object -Property ObjectType -Match ServicePrincipal $CountGroupOwners = ($Users | Measure-Object).count Write-Host &quot;[+] Discovered $CountGroupOwners group owners&quot; # Retrieving privileged service principals $ServicePrincipals = Get-AzureADPrivilegedRolesMembers -ReturnServicePrincipals $AllServicePrincipals += $ServicePrincipals $CountServicePrincipals = ($ServicePrincipals | Measure-Object).count Write-Host &quot;[+] Discovered $CountServicePrincipals service principals&quot; # Retrieving privileged service principal owners $ServicePrincipalOwners = Get-AzureADPrivilegedRolesMembers -ReturnServicePrincipals | Get-AzureADServicePrincipalOwner $AllUsers += $ServicePrincipalOwners $CountServicePrincipalOwners = ($ServicePrincipalOwners | Measure-Object).count Write-Host &quot;[+] Discovered $CountServicePrincipalOwners service principal owners&quot; $CountAllUsers = ($AllUsers | Measure-Object).count Write-Host &quot;[+] Found $CountAllUsers highly privileged users&quot; $CountAllServicePrincipals = ($AllServicePrincipals | Measure-Object).count Write-Host &quot;[+] Found $CountAllServicePrincipals highly privileged service principals&quot; $AllUsers = $AllUsers | Sort-Object -Unique $AllServicePrincipals = $AllServicePrincipals | Sort-Object -Unique $Output += $AllUsers $Output += $AllServicePrincipals } end { return $Output | ft -Force }}The output:Get-AzureADPrivilegedIdentities[+] Discovered 2 users[+] Discovered 2 group owners[+] Discovered 1 service principals[+] Discovered 1 service principal owners[+] Found 4 highly privileged users[+] Found 2 highly privileged service principalsObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------2cc999ae-fe8e-4ce9-a18a-309d68f5bce2 GroupOwnerUser GroupOwnerUser@jonyschats.nl Member59b28e90-d96b-410b-acc6-fa9ee823bfbd ServicePrincipalOwner ServicePrincipalOwner@jonyschats.nl Member766787e8-82c1-4062-bfa9-5d4a4ca300f3 0xjs 0xjs@jonyschats.nl Membereb815e66-31a5-45ca-bed8-2b0f5e24f62f GroupUser GroupUser@jonyschats.nl Member5530a9cf-a45a-4662-9179-eaa8d9089605 Test_enterpriseapp5fef25d5-9886-42df-9d98-de37f6ffd299 Test_enterpriseapp_ownerMFA ConfigurationOne good thing to check is if all users have MFA enabled. To check this the command Get-MsolUser from the MSOnline module can be used. The interesting attributes related to MFA are: StrongAuthenticationMethods and StrongAuthenticationRequirements. When we query the user 0xjs from my tenant we can see the following:Get-MsolUser -ObjectId 766787e8-82c1-4062-bfa9-5d4a4ca300f3 | Select-Object Displayname, StrongAuthenticationMethods, StrongAuthenticationRequirements |flDisplayName : 0xjsStrongAuthenticationMethods : {Microsoft.Online.Administration.StrongAuthenticationMethod, Microsoft.Online.Administration.StrongAuthenticationMethod, Microsoft.Online.Administration.StrongAuthenticationMethod, Microsoft.Online.Administration.StrongAuthenticationMethod}StrongAuthenticationRequirements : {Microsoft.Online.Administration.StrongAuthenticationRequirement}The attribute StrongAuthenticationMethods holds another PowerShell object and when we open it up we retrieve every authentication method configured and which one is the default. In the example below the PhoneAppNotification is the default MFA method but SMS, Phonecall and a OTP method is also enabled for the user 0xjs. This is because I configured every authentication method possible on my account.(Get-MsolUser -ObjectId 766787e8-82c1-4062-bfa9-5d4a4ca300f3 | Select-Object Displayname, StrongAuthenticationMethods, StrongAuthenticationRequirements).StrongAuthenticationMethodsExtensionData IsDefault MethodType------------- --------- ----------System.Runtime.Serialization.ExtensionDataObject False OneWaySMSSystem.Runtime.Serialization.ExtensionDataObject False TwoWayVoiceMobileSystem.Runtime.Serialization.ExtensionDataObject False PhoneAppOTPSystem.Runtime.Serialization.ExtensionDataObject True PhoneAppNotificationWhen we query the user SecurityReader where I didn’t configure every method we only see two methods enabled:(Get-MsolUser -ObjectId fb8a7905-e32c-4431-9e66-2968013f924f | Select-Object Displayname, StrongAuthenticationMethods, StrongAuthenticationRequirements).StrongAuthenticationMethodsExtensionData IsDefault MethodType------------- --------- ----------System.Runtime.Serialization.ExtensionDataObject True PhoneAppNotificationSystem.Runtime.Serialization.ExtensionDataObject False PhoneAppOTPThe attribute StrongAuthenticationRequirements holds the Per-User MFA configuration. This configuration should not be used if Conditional Access policies exist since it will overwrite them and will always require MFA even if the policies say it doesn’t need to.(Get-MsolUser -ObjectId 766787e8-82c1-4062-bfa9-5d4a4ca300f3 | Select-Object Displayname, StrongAuthenticationMethods, StrongAuthenticationRequirements).StrongAuthenticationRequirementsExtensionData RelyingParty RememberDevicesNotIssuedBefore State------------- ------------ ------------------------------ -----System.Runtime.Serialization.ExtensionDataObject * 11/11/2022 10:36:14 AM EnforcedTo combine this information I created the cmdlet Get-AzureADUserMFAConfiguration. This cmdlet takes a user from Get-MsolUser or Get-AzureAdUser. By default it will display if MFA is configured and what the default MFA method is and what the status is of Per-User MFA.Function Get-AzureADUserMFAConfiguration{&amp;lt;#.SYNOPSISAuthor: Jony Schats - 0xjsRequired Dependencies: Get-MsolUserOptional Dependencies: None.DESCRIPTIONGet MFA configuration data for the user. Requires a user as input..PARAMETER DetailedIf specified will create detailed MFA configuration objects.EXAMPLEGet-AzureADUser | Get-AzureADUserMFAConfigurationGet MFA configuration data of all users.EXAMPLEGet-MsolUser | Get-AzureADUserMFAConfigurationGet MFA configuration data of all users.EXAMPLEGet-MsolUser | Get-AzureADUserMFAConfiguration -DetailedGet detailed MFA configuration data of all users.EXAMPLEGet-AzureADPrivilegedRolesMembers | Get-AzureADUserMFAConfigurationGet MFA configuration data for all users of privileges roles.EXAMPLEGet-AzureADPrivilegedRolesMembers | Get-AzureADUserMFAConfiguration -DetailedGet detailed MFA configuration data for all users of privileges roles#&amp;gt; [OutputType(&#39;System.Management.Automation.PSCustomObject&#39;)] [cmdletbinding()] param( [parameter(Mandatory=$True,ValueFromPipeline=$true)] $User, [Parameter(Mandatory = $false)] [Switch] $Detailed ) Begin{ # Check if MSOnline is loaded If(-not(Get-Command *Get-MsolCompanyInformation*)){ Write-Host -ForegroundColor Red &quot;MSOnline Module not imported, stopping&quot; break } # Check connection with MSOnline try { $var = Get-MsolDomain -ErrorAction Stop &amp;gt; $null } catch { Write-Host -ForegroundColor Red &quot;You&#39;re not connected with MSOnline, Connect with Connect-MsolService&quot; break } $Output = @() } Process { $User = Get-MsolUser -ObjectId $_.ObjectId $MFADefault = &quot;&quot; $MFAConfigured = &quot;&quot; $MFADefaultMethod = &quot;&quot; $MFADefault = $User.StrongAuthenticationMethods | Where-Object -Property IsDefault -EQ $True | Select-Object -ExpandProperty MethodType if ($User.StrongAuthenticationMethods) { $MFAConfigured = $true } else { $MFAConfigured = $false } if ($MFADefault -eq &quot;PhoneAppNotification&quot;) { $MFADefaultMethod = &quot;Microsoft Authenticator&quot; } elseif ($MFADefault -eq &quot;PhoneAppOTP&quot;) { $MFADefaultMethod = &quot;HW token / Authenticator&quot; } elseif ($MFADefault -eq &quot;OneWaySMS&quot;) { $MFADefaultMethod = &quot;SMS&quot; } elseif ($MFADefault -eq &quot;TwoWayVoiceMobile&quot;) { $MFADefaultMethod = &quot;Voice&quot; } $item = New-Object PSObject $item | Add-Member -type NoteProperty -Name &#39;UserPrincipalName&#39; -Value $User.UserPrincipalName $item | Add-Member -type NoteProperty -Name &#39;MFA Configured&#39; -Value $MFAConfigured $item | Add-Member -type NoteProperty -Name &#39;MFA Default&#39; -Value $MFADefaultMethod if ($User.StrongAuthenticationRequirements) { $item | Add-Member -type NoteProperty -Name &#39;Per-User MFA&#39; -Value $User.StrongAuthenticationRequirements.State } else { $item | Add-Member -type NoteProperty -Name &#39;Per-User MFA&#39; -Value &quot;-&quot; } if ($Detailed){ if ($User.StrongAuthenticationMethods.MethodType -contains &quot;OneWaySMS&quot;) { $item | Add-Member -type NoteProperty -Name &#39;OneWaySMS&#39; -Value $true } else { $item | Add-Member -type NoteProperty -Name &#39;OneWaySMS&#39; -Value &quot;-&quot; } if ($User.StrongAuthenticationMethods.MethodType -contains &quot;TwoWayVoiceMobile&quot;) { $item | Add-Member -type NoteProperty -Name &#39;TwoWayVoiceMobile&#39; -Value $true } else { $item | Add-Member -type NoteProperty -Name &#39;TwoWayVoiceMobile&#39; -Value &quot;-&quot; } if ($User.StrongAuthenticationMethods.MethodType -contains &quot;PhoneAppOTP&quot;) { $item | Add-Member -type NoteProperty -Name &#39;PhoneAppOTP&#39; -Value $true } else { $item | Add-Member -type NoteProperty -Name &#39;PhoneAppOTP&#39; -Value &quot;-&quot; } if ($User.StrongAuthenticationMethods.MethodType -contains &quot;PhoneAppNotification&quot;) { $item | Add-Member -type NoteProperty -Name &#39;PhoneAppNotification&#39; -Value $true } else { $item | Add-Member -type NoteProperty -Name &#39;PhoneAppNotification&#39; -Value &quot;-&quot; } if ($User.StrongAuthenticationUserDetails.Email) { $item | Add-Member -type NoteProperty -Name &#39;Registered Email&#39; -Value $User.StrongAuthenticationUserDetails.Email } else { $item | Add-Member -type NoteProperty -Name &#39;Registered Email&#39; -Value &quot;-&quot; } if ($User.StrongAuthenticationUserDetails.PhoneNumber) { $item | Add-Member -type NoteProperty -Name &#39;Registered Phone&#39; -Value $User.StrongAuthenticationUserDetails.PhoneNumber } else { $item | Add-Member -type NoteProperty -Name &#39;Registered Phone&#39; -Value &quot;-&quot; } } $Output += $item } end { $Output }}Example output:Get-MsolUser -ObjectId 766787e8-82c1-4062-bfa9-5d4a4ca300f3 | Get-AzureADUserMFAConfigurationUserPrincipalName MFA Configured MFA Default Per-User MFA----------------- -------------- ----------- ------------0xjs@jonyschats.nl True Microsoft Authenticator EnforcedIt is also possible to pipe all users to this cmdlet (might take a while in big environments):Get-MsolUser | Get-AzureADUserMFAConfigurationUserPrincipalName MFA Configured MFA Default Per-User MFA----------------- -------------- ----------- ------------NestedGroupUser@jonyschats.nl True HW token / Authenticator -GroupOwnerUser@jonyschats.nl False -ServicePrincipalOwner@jonyschats.nl False -0xjs@jonyschats.nl True Microsoft Authenticator EnforcedGroupUser@jonyschats.nl True Microsoft Authenticator -SecurityReader@jonyschats.nl True Microsoft Authenticator -If detailed information is prefered there is a flag for that, use the -Detailed flag and the output will be:Get-MsolUser | Get-AzureADUserMFAConfiguration -DetailedUserPrincipalName : NestedGroupUser@jonyschats.nlMFA Configured : TrueMFA Default : HW token / AuthenticatorPer-User MFA : -OneWaySMS : -TwoWayVoiceMobile : -PhoneAppOTP : TruePhoneAppNotification : -Registered Email : -Registered Phone : -...snip...UserPrincipalName : 0xjs@jonyschats.nlMFA Configured : TrueMFA Default : Microsoft AuthenticatorPer-User MFA : EnforcedOneWaySMS : TrueTwoWayVoiceMobile : TruePhoneAppOTP : TruePhoneAppNotification : TrueRegistered Email : fakeemail@jonyschats.nlRegistered Phone : +31 06123456789...snip...UserPrincipalName : SecurityReader@jonyschats.nlMFA Configured : TrueMFA Default : Microsoft AuthenticatorPer-User MFA : -OneWaySMS : -TwoWayVoiceMobile : -PhoneAppOTP : TruePhoneAppNotification : TrueRegistered Email : -Registered Phone : -Remember when we were talking about privileged users and objects etc. We can also pipe these users to the cmdlet and quickly retrieve the MFA configuration of all privileged users within the tenant. Serviceprincipals can’t have MFA configured!Get-AzureADPrivilegedRolesMembers | Get-AzureADUserMFAConfigurationUserPrincipalName MFA Configured MFA Default Per-User MFA----------------- -------------- ----------- ------------0xjs@jonyschats.nl True Microsoft Authenticator EnforcedGroupUser@jonyschats.nl True Microsoft Authenticator -We can quickly use the created cmdlets to get a overview of all privileged objects within the tenant and their MFA status and configuration and use this data to protect the Azure tenant.GitHubAll the cmdlets can be found in my GitHub project AzurePowerCommands." }, { "title": "Service principals, did you know they can have owners too?", "url": "/posts/Service-principals-did-you-know-they-can-have-owners-too/", "categories": "Ethical Hacking, Azure", "tags": "ethical hacking, azure", "date": "2022-11-28 20:12:00 +0100", "snippet": "IntroductionThis is the third blog in the series. If you haven’t read the first or second blog I recommend reading them. In the previous blogpost we focussed on retrieving group owners and that they should be considered as high privileged users if the group he owns is member of a high privileged role. In this blogpost we will have a look at Service Principals and they can have owners too!Service princpalsIn the first blog we discussed that there are three identities that can access resources; Users, Groups and Service Principals. You might be wondering what is a service principal, Microsoft defines;A service principal is created in each tenant where the application is used and references the globally unique app object. The service principal object defines what the app can actually do in the specific tenant, who can access the app, and what resources the app can access.As an example I created an app in my Azure Active Directory in “App registrations” with the name Test_enterpriseapp.When creating the app, a service principal is automatically registered and can be found in the “Enterprise application” section of Azure Active Directory.If my app needs to access any resources within my Azure tenant it will use this service principal. For example; I could give this service principal permissions to read certain keys or certificates out of a Azure keyvault. When I give a app from somebody else permissions to access my tenant, a service principal is also created. This could be an app from somebody else or for Example Microsoft Graph Explorer. After logging in I receive a prompt to give permissions:After giving consent the service principal is added to our tenant with permissions and rolesIn a later blog we will dive into these permissions since its a complicated concept.Service princpals ownersJust like the groups, a service principal can also have an owner. So if a high priviliged role has a service principal in its member and that service principal has a owner, this user should also be considered highly privileged. In my tenant I added the service principal Test_enterpriseapp to the Authentication Administrator role and added a user ServicePrincipalOwner as owner of the service principal.To accomodate retrieving the service principals in the cmdlets of AzurePowerCommands I added the -ReturnServicePrincipals parameter which will return service principals in the same way I did for the -ReturenGroups.When you run the cmdlet Get-AzureADPrivilegedRolesMembers with the parameter -ReturnServicePrincipals it will search recursivly through the 14 roles for service principals and return them:Get-AzureADPrivilegedRolesMembers -ReturnServicePrincipalsObjectId AppId DisplayName-------- ----- -----------5530a9cf-a45a-4662-9179-eaa8d9089605 1a93dd32-5ade-4656-9ada-6a285676eb92 Test_enterpriseappWhen we run Get-AzureADPrivilegedRolesMembers -ReturnServicePrincipals and pipe it to Get-AzureADServicePrincipalOwner. The following will happen: loop through the 14 privileged roles search for all service principals and also in groups and return service principals these service principals will be piped to retrieve the owners of all the service principalsGet-AzureADPrivilegedRolesMembers -ReturnServicePrincipals | Get-AzureADServicePrincipalOwnerObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------59b28e90-d96b-410b-acc6-fa9ee823bfbd ServicePrincipalOwner ServicePrincipalOwner@jonyschats.nl MemberUpdating the overview cmdletTo get a good overview again I changed the existing Get-AzureADPrivilegedRolesOverview cmdlet and added the SPsCount, SPs and SPsOwners attributes.Function Get-AzureADPrivilegedRolesOverview{&amp;lt;#.SYNOPSISAuthor: Jony Schats - 0xjsRequired Dependencies: Get-AzureADDirectoryRole, Get-AzureADDirectoryRoleMember, Get-AzureADGroupMember, Get-AzureADGroupMemberRecursiveOptional Dependencies: None.DESCRIPTIONRecursively search through privileged Azure AD roles and return a overview of the amount of members a role has and the members itself..EXAMPLEGet-AzureADPrivilegedRolesOverview#&amp;gt; Begin{ # Check if Azure AD is loaded If(-not(Get-Command *Get-AzureADCurrentSessionInfo*)){ Write-Host -ForegroundColor Red &quot;AzureAD Module not imported, stopping&quot; break } # Check connection with AzureAD try { $var = Get-AzureADTenantDetail } catch { Write-Host -ForegroundColor Red &quot;You&#39;re not connected with AzureAD, Connect with Connect-AzureAD&quot; break } $AdminRoles = &quot;Global administrator&quot;, &quot;Application administrator&quot;, &quot;Authentication Administrator&quot;, &quot;Billing administrator&quot;, &quot;Cloud application administrator&quot;, &quot;Conditional Access administrator&quot;, &quot;Exchange administrator&quot;, &quot;Helpdesk administrator&quot;, &quot;Password administrator&quot;, &quot;Privileged authentication administrator&quot;, &quot;Privileged Role Administrator&quot;, &quot;Security administrator&quot;, &quot;SharePoint administrator&quot;, &quot;User administrator&quot; $Output = @() } Process { foreach ($AdminRole in $AdminRoles) { $AdminRoleData = Get-AzureADDirectoryRole | Where-Object -Property Displayname -eq $AdminRole Write-Verbose -Message &quot;Enumerating $($AdminRoleData.DisplayName)&quot; # If the role is populated if ($AdminRoleData -ne $null){ # Retrieve members of the AdminRole $AdminRoleMembersUsers = Get-AzureADDirectoryRole -ObjectId $AdminRoleData.ObjectId | Get-AzureADDirectoryRoleMemberRecursive $AdminRoleMembersUsersCount = $AdminRoleMembersUsers | Sort-Object -Unique | Measure-Object $AdminRoleMembersGroups = Get-AzureADDirectoryRole -ObjectId $AdminRoleData.ObjectId | Get-AzureADDirectoryRoleMemberRecursive -ReturnGroups $AdminRoleMembersGroupsCount = $AdminRoleMembersGroups | Sort-Object -Unique | Measure-Object $GroupOwners = Get-AzureADDirectoryRole -ObjectId $AdminRoleData.ObjectId | Get-AzureADDirectoryRoleMemberRecursive -ReturnGroups | Get-AzureADGroupOwner $AdminRoleMembersSPs = Get-AzureADDirectoryRole -ObjectId $AdminRoleData.ObjectId | Get-AzureADDirectoryRoleMemberRecursive -ReturnServicePrincipals $AdminRoleMembersSPsCount = $AdminRoleMembersSPs | Sort-Object -Unique | Measure-Object $ServicePrincipalOwners = Get-AzureADDirectoryRole -ObjectId $AdminRoleData.ObjectId | Get-AzureADDirectoryRoleMemberRecursive -ReturnServicePrincipals | Get-AzureADServicePrincipalOwner $item = New-Object PSObject $item | Add-Member -type NoteProperty -Name &#39;Role&#39; -Value $AdminRoleData.DisplayName $item | Add-Member -type NoteProperty -Name &#39;UserCount&#39; -Value $AdminRoleMembersUsersCount.Count $item | Add-Member -type NoteProperty -Name &#39;Users&#39; -Value $AdminRoleMembersUsers.UserPrincipalName $item | Add-Member -type NoteProperty -Name &#39;GroupCount&#39; -Value $AdminRoleMembersGroupsCount.Count $item | Add-Member -type NoteProperty -Name &#39;Groups&#39; -Value $AdminRoleMembersGroups.DisplayName $item | Add-Member -type NoteProperty -Name &#39;GroupOwners&#39; -Value $GroupOwners.UserPrincipalName $item | Add-Member -type NoteProperty -Name &#39;SPsCount&#39; -Value $AdminRoleMembersSPsCount.Count $item | Add-Member -type NoteProperty -Name &#39;SPs&#39; -Value $AdminRoleMembersSPs.DisplayName $item | Add-Member -type NoteProperty -Name &#39;SPsOwners&#39; -Value $ServicePrincipalOwners.UserPrincipalName $Output += $item } else { $item = New-Object PSObject $item | Add-Member -type NoteProperty -Name &#39;Role&#39; -Value $AdminRole $item | Add-Member -type NoteProperty -Name &#39;UserCount&#39; -Value &quot;0&quot; $item | Add-Member -type NoteProperty -Name &#39;GroupCount&#39; -Value &quot;0&quot; $item | Add-Member -type NoteProperty -Name &#39;SPsCount&#39; -Value &quot;0&quot; $Output += $item } } } end { Return $Output | Sort-Object -Property UserCount -Descending }}The output:Get-AzureADPrivilegedRolesOverview | ftRole UserCount Users GroupCount Groups GroupOwners SPsCount SPs SPsOwners---- --------- ----- ---------- ------ ----------- -------- --- ---------Authentication Administrator 1 GroupUser@jonyschats.nl 1 Administrator ServicePrincipalOwner@jonyschats.nl 1 Test_enterpriseapp ServicePrincipalOwner@jonyschats.nlGlobal Administrator 1 0xjs@jonyschats.nl 0 0Privileged Role Administrator 0 0 0Privileged authentication administrator 0 0 0Password administrator 0 0 0User Administrator 0 0 0SharePoint administrator 0 0 0Security administrator 0 0 0Cloud application administrator 0 0 0Billing administrator 0 0 0Application administrator 0 0 0Helpdesk administrator 0 0 0Exchange administrator 0 0 0Conditional Access administrator 0 0 0Quick recapA quick recap of what we have learned about Azure AD identities: Roles can be assigned these three identities and these identities: Users Groups Can’t have nested groups when assigned to roles. Can have owners ServicePrincipals Can have Owners Can have permissions In the next blog we will dive into retrieving all the privileged identities and checking their MFA configuration.GitHubAll the cmdlets can be found in my GitHub project AzurePowerCommands." }, { "title": "PentesterAcademy Certified Enterprise Security Specialist (PACES) review", "url": "/posts/PentesterAcademy-PACES-review/", "categories": "Ethical Hacking, Reviews", "tags": "ethical hacking", "date": "2022-11-25 17:44:00 +0100", "snippet": "IntroductionI just passed the PentesterAcademy Certified Enterprise Security Specialist exam. The lab and the course is made by PentesterAcademy and is known as the Global Central Bank(GCB). It is the biggest red teaming Active Directory lab they offer.The materialThe GCB course consists out of nine videos with a total length of 3 hours. The video’s covers topics such as: PAM Trusts Local Administrator Password Solution (LAPS) PowerShell Web Access (PSWA) Windows Linux subsystem (WSL) Unconstrained delegation and the printer bug Resource Based Constrained Delegation (RBCD) Just Enough Admin (JEA) ExchangeThey course introduces new concepts and its expected to have the knowledge from CRTP and CRTE. With the material they also give attack path diagrams for whenever you are stuck, these diagrams give small hints on which and how the next machine could be exploited.The labsThe lab consists out of 7 forests, 9 domains and around 25-30 machines. The lab exercises are split into 12 sections and multiple attack paths. When you start the lab you are provided with a VPN pack and Apache Guacamole browser access. I prefered the lab pack and used that to RDP into the Windows attacking machine. It is expected that you execute the attacks from this VM and bring your own toolset. There is nothing installed on the machine and you don’t start with high privileges.The lab was big and is good designed which made it fun to exploit everything and progress in the lab. I was already familiar with most abuses and misconfigurations except PAM, PSWA, WSL and JEA. The part were I struggled the most was in the post-exploitation fase where you needed to find some kind of information from enterprise applications or for example the DNS service on the DC. However whenever you are stuck you can mail the lab team and they will give you some information on how to progress further! The lab really looks like the drawing on their website!It took me around three weeks to complete the lab. I think I did it pretty fast because I spent quite some time on it during those weeks and I was already familiair with the concepts. I bought one month of lab access so I knew I had to push it to make it since most people recommended two months of access.The examThe exam environment exists out of five machines with the goal to get command execution on each of them. A big difference compared to CRTP and CRTE is that it is also required to fully remediate the attacks, misconfigurations and abuses while not breaking functionality in the lab. They will give a list of functionalities which should still work after patching to be able to pass. It is also required to fully document the implementation of the remediations and why you chosen to do so.My exam experiencesI thought I was starting the exam at 9 AM in the morning but apperantly it was 10 AM. The exam environment has the same connectivity options as in the lab, either VPN or Apache Guacamole via the browser. The exam environment was stable and I didn’t have any connectivity issues nor have to deal with slow machines. Everything was fast, which I liked.For me the exam itself wasn’t hard, not like how the lab was. But this also might be because I have a lot of experience atttacking Active Directory. The lab definitly prepares you well for the exam. If you have completed the whole lab and if you remediated everything inside the lab you should be able to pass the exam.Tips for the lab &amp;amp; certifiationI would highly recommend building your own AD lab locally, this really helped me during the remediation fase of the lab and exam since I basicly knew how you configure these vulnerabilities, so you also know how to fix it. You can find more on how I built a lab here.For in the lab my tips are: Do a lot of post-exploitation and also think outside of On-Prem AD. Keep scanning the network from each compromised machine with for example Invoke-Portscanner or the extra function I posted hereEverything learned from the course is added to my cheatsheet." }, { "title": "Do you check for group owners of privileged roles?", "url": "/posts/Do-you-check-for-group-owners-of-privileged-roles/", "categories": "Ethical Hacking, Azure", "tags": "ethical hacking, azure", "date": "2022-11-15 19:40:00 +0100", "snippet": "IntroductionThis is the second blog in the series. If you havent read the first one you can find it here. In the previous blogpost we focussed on retrieving userobjects from groups and roles and created a PowerShell cmdlet to get a overview of the users of 14 privileged roles. The created PowerShell cmdlet Get-AzureADPrivilegedRolesMembers searches recursivly through all these roles and return all the userobjects. This blog we will focus on group owners and enumerating them.Group OwnersA group owner can add members to the group without being part of the group. This is important when searching for privileged users since the following scenario could exist in Azure tenants:A privileged role has one membership, which is a group. This group has one member Bob, but the user Alice own’s this group. This owner can add members to this group, resulting in the assignment of the role to the user. In my tenant I configured the following: The Authentication Administrator role has one membership which is the group Administrator. The group has one member which is Groupuser and the owner of the group is GroupOwnerUser.When we run the created PowerShell cmdlet Get-AzureADDirectoryRoleMemberRecursive to list all the members of the role Authenticated Administrators it returns the user Groupuser:Get-AzureADDirectoryRole -ObjectId 594857e7-f7b4-4fd0-892b-6e1e66237b8f | Get-AzureADDirectoryRoleMemberRecursiveObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------eb815e66-31a5-45ca-bed8-2b0f5e24f62f GroupUser GroupUser@jonyschats.nl MemberBut it doesn’t take into account the owner of the group. When we query the memberships of the role we see that the Administrator group is a member and when we query the owner of the group we see that GroupOwnerUser is owner of the group:Get-AzureADDirectoryRoleMember -ObjectId 594857e7-f7b4-4fd0-892b-6e1e66237b8fObjectId DisplayName Description-------- ----------- -----------58b18ca8-2b9d-49b0-acfa-d0a68299a580 AdministratorGet-AzureADGroupOwner -ObjectId 58b18ca8-2b9d-49b0-acfa-d0a68299a580ObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------2cc999ae-fe8e-4ce9-a18a-309d68f5bce2 GroupOwnerUser GroupOwnerUser@jonyschats.nl MemberChanging the already created cmdletsA group owner can add members to that group. This means that the user GroupOwnerUser can add members to the group Administrator, which will give the newly added user the role Authentication administrator. Group owners can add themself and should be considered as highly privileged users if they own a group which is a member of a high privileged role.To retrieve group objects even if they are nested I changed the Get-AzureADGroupMemberRecursive function and added the -ReturnGroups parameter which will make the function return groups instead of users....snip...Write-Verbose -Message &quot;Enumerating $($AzureGroup.DisplayName)&quot;$Members = Get-AzureADGroupMember -ObjectId $AzureGroup.ObjectId -All $trueif ($ReturnGroups){ $UserMembers = $Members | Where-Object{$_.ObjectType -eq &#39;Group&#39;} $Output += $UserMembers $GroupMembers = $Members | Where-Object{$_.ObjectType -eq &#39;Group&#39;} If($GroupMembers){ $UserMembers = $GroupMembers | ForEach-Object{ Get-AzureADGroupMemberRecursive -ReturnGroups -AzureGroup $_} $Output += $UserMembers }}else { $UserMembers = $Members | Where-Object{$_.ObjectType -eq &#39;User&#39;} $Output += $UserMembers $GroupMembers = $Members | Where-Object{$_.ObjectType -eq &#39;Group&#39;} If($GroupMembers){ $UserMembers = $GroupMembers | ForEach-Object{ Get-AzureADGroupMemberRecursive -AzureGroup $_} $Output += $UserMembers }}...snip...The cmdlet now returns only group objects when the parameter is given, to be sure it searched recusivly I created a extra group NestedNestedgroup and placed it inside the group Nestedgroup. The membership structure is as follows: Test Group NestedGroup NestedNestedgroup Get-AzureADGroup -ObjectId f5108639-9aca-4694-864e-c4e00186706b | Get-AzureADGroupMemberRecursive -ReturnGroupsObjectId DisplayName Description-------- ----------- -----------50c16bf1-5016-4dfe-8bcc-d273c3b02f02 NestedGroup8510e6c0-fa05-49ca-ab5c-26d3d59a2e4d NestedNestedGroupI also changed the Get-AzureADGroupMemberRecursive cmdlet and added the parameter -ReturnGroups. I made the same changes to Get-AzureADPrivilegedRolesMembers. When you run the cmdlet now with the parameter -ReturnGroups it will search recursivly through the 14 roles for group objects and return them:Get-AzureADPrivilegedRolesMembers -ReturnGroupsObjectId DisplayName Description-------- ----------- -----------58b18ca8-2b9d-49b0-acfa-d0a68299a580 AdministratorThen I tried adding a group to the Administrator group to create a nested group effect. But I figured out that is not possible since you can’t create nested groups if the group is elligible to be assigned to a role. Well okay, atleast my function is future proof if add that ability. Facepalm!When we run Get-AzureADPrivilegedRolesMembers -ReturnGroups and pipe it to Get-AzureADGroupOwner. The following will happen: loop through the 14 privileged roles list all the group objects and return group objects these group objects will be piped to retrieve the owners of all the groupsGet-AzureADPrivilegedRolesMembers -ReturnGroups | Get-AzureADGroupOwnerObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------2cc999ae-fe8e-4ce9-a18a-309d68f5bce2 GroupOwnerUser GroupOwnerUser@jonyschats.nl MemberSo even though the user GroupOwnerUser@jonyschats.nl doesn’t have a role that gives him high privileges, the user should be considered as a high privileged user since he owns a group which is member of a high privileged role.Updating the overview cmdletTo get a good overview again I changed the existing Get-AzureADPrivilegedRolesOverview cmdlet and added the groupcount, groups and groupowners attributes.Function Get-AzureADPrivilegedRolesOverview{&amp;lt;#.SYNOPSISAuthor: Jony Schats - 0xjsRequired Dependencies: Get-AzureADDirectoryRole, Get-AzureADDirectoryRoleMember, Get-AzureADGroupMember, Get-AzureADGroupMemberRecursiveOptional Dependencies: None.DESCRIPTIONRecursively search through privileged Azure AD roles and return a overview of the amount of members a role has and the members itself..EXAMPLEGet-AzureADPrivilegedRolesOverview#&amp;gt; Begin{ # Check if Azure AD is loaded If(-not(Get-Command *Get-AzureADCurrentSessionInfo*)){ Write-Host -ForegroundColor Red &quot;AzureAD Module not imported, stopping&quot; break } # Check connection with AzureAD try { $var = Get-AzureADTenantDetail } catch { Write-Host -ForegroundColor Red &quot;You&#39;re not connected with AzureAD, Connect with Connect-AzureAD&quot; break } $AdminRoles = &quot;Global administrator&quot;, &quot;Application administrator&quot;, &quot;Authentication Administrator&quot;, &quot;Billing administrator&quot;, &quot;Cloud application administrator&quot;, &quot;Conditional Access administrator&quot;, &quot;Exchange administrator&quot;, &quot;Helpdesk administrator&quot;, &quot;Password administrator&quot;, &quot;Privileged authentication administrator&quot;, &quot;Privileged Role Administrator&quot;, &quot;Security administrator&quot;, &quot;SharePoint administrator&quot;, &quot;User administrator&quot; $Output = @() } Process { foreach ($AdminRole in $AdminRoles) { $AdminRoleData = Get-AzureADDirectoryRole | Where-Object -Property Displayname -eq $AdminRole Write-Verbose -Message &quot;Enumerating $($AdminRoleData.DisplayName)&quot; # If the role is populated if ($AdminRoleData -ne $null){ # Retrieve members of the AdminRole $AdminRoleMembersUsers = Get-AzureADDirectoryRole -ObjectId $AdminRoleData.ObjectId | Get-AzureADDirectoryRoleMemberRecursive $AdminRoleMembersUsersCount = $AdminRoleMembersUsers | Sort-Object -Unique | Measure-Object $AdminRoleMembersGroups = Get-AzureADDirectoryRole -ObjectId $AdminRoleData.ObjectId | Get-AzureADDirectoryRoleMemberRecursive -ReturnGroups $AdminRoleMembersGroupsCount = $AdminRoleMembersGroups | Sort-Object -Unique | Measure-Object $GroupOwners = Get-AzureADDirectoryRole -ObjectId $AdminRoleData.ObjectId | Get-AzureADDirectoryRoleMemberRecursive -ReturnGroups | Get-AzureADGroupOwner $item = New-Object PSObject $item | Add-Member -type NoteProperty -Name &#39;Role&#39; -Value $AdminRoleData.DisplayName $item | Add-Member -type NoteProperty -Name &#39;UserCount&#39; -Value $AdminRoleMembersUsersCount.Count $item | Add-Member -type NoteProperty -Name &#39;Users&#39; -Value $AdminRoleMembersUsers.UserPrincipalName $item | Add-Member -type NoteProperty -Name &#39;GroupCount&#39; -Value $AdminRoleMembersGroupsCount.Count $item | Add-Member -type NoteProperty -Name &#39;Groups&#39; -Value $AdminRoleMembersGroups.DisplayName $item | Add-Member -type NoteProperty -Name &#39;GroupOwners&#39; -Value $GroupOwners.UserPrincipalName $Output += $item } else { $item = New-Object PSObject $item | Add-Member -type NoteProperty -Name &#39;Role&#39; -Value $AdminRole $item | Add-Member -type NoteProperty -Name &#39;UserCount&#39; -Value &quot;0&quot; $item | Add-Member -type NoteProperty -Name &#39;GroupCount&#39; -Value &quot;0&quot; $Output += $item } } } end { Return $Output | Sort-Object -Property UserCount -Descending }}The output of the new cmdlet looks like:Get-AzureADPrivilegedRolesOverview | ftRole UserCount Users GroupCount Groups GroupOwners---- --------- ----- ---------- ------ -----------Authentication Administrator 1 GroupUser@jonyschats.nl 1 Administrator GroupOwnerUser@jonyschats.nlGlobal Administrator 1 0xjs@jonyschats.nl 0Privileged Role Administrator 0 0Privileged authentication administrator 0 0Password administrator 0 0User Administrator 0 0SharePoint administrator 0 0Security administrator 0 0Cloud application administrator 0 0Billing administrator 0 0Application administrator 0 0Helpdesk administrator 0 0Exchange administrator 0 0Conditional Access administrator 0 0Quick recapA quick recap of what I have learned about Azure AD identities: Roles can be assigned these three identities and these identities: Users Groups Can’t have nested groups when assigned to roles. Can have owners ServicePrincipals In the next blog we will dive into ServicePrincipals and yes these can have owners too.GitHubAll the cmdlets can be found in my GitHub project AzurePowerCommand." }, { "title": "Searching recursivly through Azure AD Groups and Roles", "url": "/posts/Searching-recursivl-through-Azure-AD-Groups-and-Roles/", "categories": "Ethical Hacking, Azure", "tags": "ethical hacking, azure", "date": "2022-11-12 12:45:00 +0100", "snippet": "IntroductionDuring some courses I have been working with the AzureAD PowerShell Module to retrieve information from Users, Groups, Roles etc. While working with these cmdlets it was annoying that it doesn’t have a functionality to recursivly search through group objects. So I wrote two modules to recursivly search through group objects and roles and only return the user objects. Then I also wanted to get a overview of the Azure AD roles and privileged roles and their users? This blogpost will be the first of the series about priviliged identities. In this blogpost I will describe and share the PowerShell cmdlets I created which will help with enumerating Azure AD Group and Role user memberships.In Azure there are three identities that can have access to resources: Users Groups Can have users, serviceprincipals or other groups as members ServicePrincipalsIn the first blog we will focus on retrieving users out of groups and roles.The problem with Azure AD cmdlets when querying for membershipsWhen quering members of a group with the cmdlet Get-AzureADGroupMember the cmdlet returns user, serviceprincipal and group objects. In the output below an example is shown where it returns the user GroupUser and the group NestedGroup.Get-AzureADGroupMember -ObjectId f5108639-9aca-4694-864e-c4e00186706bObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------eb815e66-31a5-45ca-bed8-2b0f5e24f62f GroupUser GroupUser@jonyschats.nl MemberDeletionTimestamp :ObjectId : 50c16bf1-5016-4dfe-8bcc-d273c3b02f02ObjectType : GroupDescription :DirSyncEnabled :DisplayName : NestedGroupLastDirSyncTime :Mail :MailEnabled : FalseMailNickName : 295cb161-8OnPremisesSecurityIdentifier :ProvisioningErrors : {}ProxyAddresses : {}SecurityEnabled : TrueBut it is missing the user that is part of the group NestedGroup and I would like to only retrieve the userobjects. The same happens for roles since you can assign groups and users to a role.Get-AzureADDirectoryRoleMember -ObjectId 598a6cfe-5d1a-42a7-81b6-76f4ab077152ObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------fb8a7905-e32c-4431-9e66-2968013f924f SecurityReader SecurityReader@jonyschats.nl MemberDeletionTimestamp :ObjectId : 15c39279-6020-4a08-891f-8d76b6b86036ObjectType : GroupDescription :DirSyncEnabled :DisplayName : Security Reader AD GroupLastDirSyncTime :Mail :MailEnabled : FalseMailNickName : 62ac515e-aOnPremisesSecurityIdentifier :ProvisioningErrors : {}ProxyAddresses : {}SecurityEnabled : TrueThe output is missing the user of the group Security Reader AD Group.New cmdlets for recursively searching through groups and rolesGet-AzureADGroupMemberRecursiveSo I created the PowerShell cmdlet Get-AzureADGroupMemberRecursive which takes a group object as input and recursivly searches through all group objects and returns user objects. The code of the cmdlet is:Function Get-AzureADGroupMemberRecursive{&amp;lt;#.SYNOPSISAuthor: Jony Schats - 0xjsRequired Dependencies: Get-AzureADGroupMemberOptional Dependencies: None.DESCRIPTIONRecursively search through groups and only return unique user objects. Requires the Get-AzureADGroup as input..EXAMPLEGet-AzureADGroup -ObjectId &amp;lt;ID&amp;gt; | Get-AzureADGroupMemberRecursive.EXAMPLEGet-AzureADGroup | Where-Object -Property Displayname -eq &quot;&amp;lt;GROUP&amp;gt;&quot; | Get-AzureADGroupMemberRecursive#&amp;gt; [cmdletbinding()] param( [parameter(Mandatory=$True,ValueFromPipeline=$true)] $AzureGroup ) Begin{ If(-not(Get-AzureADCurrentSessionInfo)){Connect-AzureAD} $Output = @() } Process { Write-Verbose -Message &quot;Enumerating $($AzureGroup.DisplayName)&quot; $Members = Get-AzureADGroupMember -ObjectId $AzureGroup.ObjectId -All $true $UserMembers = $Members | Where-Object{$_.ObjectType -eq &#39;User&#39;} $Output += $UserMembers $GroupMembers = $Members | Where-Object{$_.ObjectType -eq &#39;Group&#39;} If($GroupMembers){ $UserMembers = $GroupMembers | ForEach-Object{ Get-AzureADGroupMemberRecursive -AzureGroup $_} $Output += $UserMembers } } end { Return $Output | Sort-Object -Unique }}Below is example output where it retrieves the user GroupUser of the group test group, but also the user NestedGroupUser from the group NestedGroup which is member of the group test group. The membership structure is as follows: Test group GroupUser@jonyschats.nl NestedGroup NestedGroupUser@jonyschats.nl Get-AzureADGroup -ObjectId f5108639-9aca-4694-864e-c4e00186706b | Get-AzureADGroupMemberRecursiveObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------1a9a26f4-297a-4dec-95b3-e502ec8e9dfc NestedGroupUser NestedGroupUser@jonyschats.nl Membereb815e66-31a5-45ca-bed8-2b0f5e24f62f GroupUser GroupUser@jonyschats.nl MemberGet-AzureADDirectoryRoleMemberRecursiveRoles can also have user and group objects as members. So I created the PowerShell cmdlet Get-AzureADDirectoryRoleMemberRecursive which uses the Get-AzureADGroupMemberRecursive cmdlet to recursivly search through all the groups assigned to the role and returns all the users. The code of the cmdlet is:Function Get-AzureADDirectoryRoleMemberRecursive{&amp;lt;#.SYNOPSISAuthor: Jony Schats - 0xjsRequired Dependencies: Get-AzureADDirectoryRoleMember, Get-AzureADGroupMember, Get-AzureADGroupMemberRecursiveOptional Dependencies: None.DESCRIPTIONRecursively search through roles and only return unique user objects. Requires the Get-AzureADDirectoryRole as input..EXAMPLEGet-AzureADDirectoryRole -ObjectId &amp;lt;ID&amp;gt; | Get-AzureADDirectoryRoleMemberRecursive.EXAMPLEGet-AzureADDirectoryRole | Where-Object -Property Displayname -eq &quot;&amp;lt;ROLE&amp;gt;&quot; | Get-AzureADDirectoryRoleMemberRecursive#&amp;gt; [cmdletbinding()] param( [parameter(Mandatory=$True,ValueFromPipeline=$true)] $RoleGroup ) Begin{ If(-not(Get-AzureADCurrentSessionInfo)){Connect-AzureAD} $Output = @() } Process { Write-Verbose -Message &quot;Enumerating $($RoleGroup.DisplayName)&quot; $Members = Get-AzureADDirectoryRoleMember -ObjectId $RoleGroup.ObjectId $UserMembers = $Members | Where-Object{$_.ObjectType -eq &#39;User&#39;} $Output += $UserMembers $GroupMembers = $Members | Where-Object{$_.ObjectType -eq &#39;Group&#39;} If($GroupMembers){ $UserMembers = $GroupMembers | ForEach-Object{ Get-AzureADGroupMemberRecursive -AzureGroup $_} $Output += $UserMembers } } end { Return $Output | Sort-Object -Unique }}Below is example output where it retrieves the user SecurityReader of the role Security Reader but also the user NestedGroupUser from the group NestedGroup which is member of the role. The membership structure is as follows: Security Reader SecurityReader@jonyschats.nl NestedGroup NestedGroupUser@jonyschats.nl Get-AzureADDirectoryRole -ObjectId 598a6cfe-5d1a-42a7-81b6-76f4ab077152 | Get-AzureADDirectoryRoleMemberRecursiveObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------1a9a26f4-297a-4dec-95b3-e502ec8e9dfc NestedGroupUser NestedGroupUser@jonyschats.nl Memberfb8a7905-e32c-4431-9e66-2968013f924f SecurityReader SecurityReader@jonyschats.nl MemberNew cmdlets for enumerating rolesGet-AzureADDirectoryRoleOverviewAzureAD has a lot of built-in roles but the AzureAD cmdlet Get-AzureADDirectoryRole only returns the roles which are activated. Using this information we can easily request all activated roles and retrieve its users with the cmdlet I created earlier. But I woud like to get an overview of how many users each role has and who the users are. So I created the cmdlet Get-AzureADDirectoryRoleOverview:Function Get-AzureADDirectoryRoleOverview{&amp;lt;#.SYNOPSISAuthor: Jony Schats - 0xjsRequired Dependencies: Get-AzureADDirectoryRole, Get-AzureADDirectoryRoleMember, Get-AzureADGroupMember, Get-AzureADGroupMemberRecursiveOptional Dependencies: None.DESCRIPTIONRecursively search through all active Azure AD roles and return a overview of the amount of members a role has and the members itself..EXAMPLEGet-AzureADDirectoryRoleOverview#&amp;gt; Begin{ If(-not(Get-AzureADCurrentSessionInfo)){Connect-AzureAD} $Output = @() } Process { $AzureADRoles = Get-AzureADDirectoryRole foreach ($AzureADRole in $AzureADRoles) { Write-Verbose -Message &quot;Enumerating $($AzureADRole.DisplayName)&quot; # Retrieve members of the AdminRole $RoleMembers = Get-AzureADDirectoryRole -ObjectId $AzureADRole.ObjectId | Get-AzureADDirectoryRoleMemberRecursive $RoleMembersCount = $RoleMembers | Sort-Object -Unique | Measure-Object $item = New-Object PSObject $item | Add-Member -type NoteProperty -Name &#39;Role&#39; -Value $AzureADRole.DisplayName $item | Add-Member -type NoteProperty -Name &#39;UserCount&#39; -Value $RoleMembersCount.Count $item | Add-Member -type NoteProperty -Name &#39;Members&#39; -Value $RoleMembers.UserPrincipalName $Output += $item } } end { Return $Output | Sort-Object -Property UserCount -Descending }}The cmdlet retrieves all active roles and their memberships, counts the userobjects after searching recursivly and creates new PowerShell objects with the attributes Rolename, Usercount and Members.Get-AzureADDirectoryRoleOverviewRole UserCount Members---- --------- -------Security Reader 2 {NestedGroupUser@jonyschats.nl, SecurityReader@jonyschats.nl}Global Reader 1 SecurityReader@jonyschats.nlGlobal Administrator 1 0xjs@jonyschats.nlGet-AzureADPrivilegedRolesMembersWe got an overview of all roles used within Azure, the member count and listing the members, but what about privileged roles? There is a warning in Microsoft Security Center which recommends MFA for atleast these privileged roles. So I created the PowerShell cmdlet Get-AzureADPrivilegedRolesMembers which searches recursivly through all these roles and return all user object:Function Get-AzureADPrivilegedRolesMembers{&amp;lt;#.SYNOPSISAuthor: Jony Schats - 0xjsRequired Dependencies: Get-AzureADDirectoryRole, Get-AzureADDirectoryRoleMember, Get-AzureADGroupMember, Get-AzureADGroupMemberRecursiveOptional Dependencies: None.DESCRIPTIONRecursively search through privileged roles and only return unique user objects..EXAMPLEGet-AzureADPrivilegedRolesMembers#&amp;gt; Begin{ If(-not(Get-AzureADCurrentSessionInfo)){Connect-AzureAD} $AdminRoles = &quot;Global administrator&quot;, &quot;Application administrator&quot;, &quot;Authentication Administrator&quot;, &quot;Billing administrator&quot;, &quot;Cloud application administrator&quot;, &quot;Conditional Access administrator&quot;, &quot;Exchange administrator&quot;, &quot;Helpdesk administrator&quot;, &quot;Password administrator&quot;, &quot;Privileged authentication administrator&quot;, &quot;Privileged Role Administrator&quot;, &quot;Security administrator&quot;, &quot;SharePoint administrator&quot;, &quot;User administrator&quot; $Output = @() } Process { foreach ($AdminRole in $AdminRoles) { $AdminRoleData = Get-AzureADDirectoryRole | Where-Object -Property Displayname -eq $AdminRole Write-Verbose -Message &quot;Enumerating $($AdminRoleData.DisplayName)&quot; # If the role is populated if ($AdminRoleData -ne $null){ # Retrieve members of the AdminRole $AdminRoleMembers = Get-AzureADDirectoryRole -ObjectId $AdminRoleData.ObjectId | Get-AzureADDirectoryRoleMemberRecursive $Output += $AdminRoleMembers } } } end { Return $Output | Sort-Object -Unique }}I only have one Global Administrator in my tenant so it returns just one object. But it will go through all 14 roles and recursivly search for all users.Get-AzureADPrivilegedRolesMembersObjectId DisplayName UserPrincipalName UserType-------- ----------- ----------------- --------766787e8-82c1-4062-bfa9-5d4a4ca300f3 0xjs 0xjs@jonyschats.nl MemberGet-AzureADPrivilegedRolesOverviewWe already created a overview of all active roles and its members, but I also wanted to have this overview for the privileged roles which we discussed earlier. So I created Get-AzureADPrivilegedRolesOverview:Function Get-AzureADPrivilegedRolesOverview{&amp;lt;#.SYNOPSISAuthor: Jony Schats - 0xjsRequired Dependencies: Get-AzureADDirectoryRole, Get-AzureADDirectoryRoleMember, Get-AzureADGroupMember, Get-AzureADGroupMemberRecursiveOptional Dependencies: None.DESCRIPTIONRecursively search through privileged Azure AD roles and return a overview of the amount of members a role has and the members itself..EXAMPLEGet-AzureADPrivilegedRolesOverview#&amp;gt; Begin{ If(-not(Get-AzureADCurrentSessionInfo)){Connect-AzureAD} $AdminRoles = &quot;Global administrator&quot;, &quot;Application administrator&quot;, &quot;Authentication Administrator&quot;, &quot;Billing administrator&quot;, &quot;Cloud application administrator&quot;, &quot;Conditional Access administrator&quot;, &quot;Exchange administrator&quot;, &quot;Helpdesk administrator&quot;, &quot;Password administrator&quot;, &quot;Privileged authentication administrator&quot;, &quot;Privileged Role Administrator&quot;, &quot;Security administrator&quot;, &quot;SharePoint administrator&quot;, &quot;User administrator&quot; $Output = @() } Process { foreach ($AdminRole in $AdminRoles) { $AdminRoleData = Get-AzureADDirectoryRole | Where-Object -Property Displayname -eq $AdminRole Write-Verbose -Message &quot;Enumerating $($AdminRoleData.DisplayName)&quot; # If the role is populated if ($AdminRoleData -ne $null){ # Retrieve members of the AdminRole $AdminRoleMembers = Get-AzureADDirectoryRole -ObjectId $AdminRoleData.ObjectId | Get-AzureADDirectoryRoleMemberRecursive $AdminRoleMembersCount = $AdminRoleMembers | Sort-Object -Unique | Measure-Object $item = New-Object PSObject $item | Add-Member -type NoteProperty -Name &#39;Role&#39; -Value $AdminRoleData.DisplayName $item | Add-Member -type NoteProperty -Name &#39;UserCount&#39; -Value $AdminRoleMembersCount.Count $item | Add-Member -type NoteProperty -Name &#39;Members&#39; -Value $AdminRoleMembers.UserPrincipalName $Output += $item } else { $item = New-Object PSObject $item | Add-Member -type NoteProperty -Name &#39;Role&#39; -Value $AdminRole $item | Add-Member -type NoteProperty -Name &#39;UserCount&#39; -Value &quot;0&quot; $Output += $item } } } end { Return $Output | Sort-Object -Property UserCount -Descending }}The PowerShell cmdlet also adds a object for the role even if its empty, but you can easily filter this by piping it to a where-object statement such as | Where-Object -Property UserCount -NE 0.Get-AzureADPrivilegedRolesOverviewRole UserCount Members---- --------- -------Global Administrator 1 0xjs@jonyschats.nlPrivileged Role Administrator 0Privileged authentication administrator 0Password administrator 0User administrator 0SharePoint administrator 0Security administrator 0Helpdesk administrator 0Billing administrator 0Authentication Administrator 0Application administrator 0Exchange administrator 0Conditional Access administrator 0Cloud application administrator 0Get-AzureADPrivilegedRolesOverview | Where-Object -Property UserCount -NE 0Role UserCount Members---- --------- -------Global Administrator 1 0xjs@jonyschats.nlGitHubAll the cmdlets can be found in my GitHub project AzurePowerCommand.The next blog in the series will be about GroupOwners." }, { "title": "PNPT review", "url": "/posts/PNPT-review/", "categories": "Ethical Hacking, Reviews", "tags": "ethical hacking", "date": "2022-06-16 16:51:00 +0200", "snippet": "IntroductionI just passed the Practical Network Penetration Tester exam. I heard a lot of good things about the course and I also received a lot of questions about if I knew the course was good. So, I decided to take the course and exam so I knew where the course was about and how good it was.The materialThe PNPT course consists out of five modules which can be bought as standalone courses, consisting off: Practical Ethical Hacking Linux Privilege Escalation for Beginners Windows Privilege Escalation for Beginners Open Source Intelligence (OSINT) Fundamentals External Pentest PlaybookThe courses covers everything needed to be able to perform a pentest on a company. From OSINT to external and internal networks, including basic Active Directory attacks and privilege escalation on Windows and Linux.I didn’t spend too much time within the course since I already had a lot of knowledge in pentesting Networks and Active Directory, so I skipped through and watched all videos at twice the speed. The whole material is purely video based with slides in the background where the cybermentor is talking about the topics in the slides. Overall the videos and the content were good, way better than some of the most recognisable certifications.One thing I was missing since I wanted to go through the material quickly was a slide deck for each section.The labsThe course doesn’t have a dedicated lab included and you need to download your own machines and run them in a hypervisor. Everything needed to build this is covered in the material, including building your own small Active Directory environment. This could be seen as a bad thing, but you will learn a lot by building your own lab and it will learn you the basics and it gives you the ability to build upon it.The examWhen you book the exam, you won’t get anything in advance. At the time the exam starts you will receive your VPN pack and the rules of engagement document describing the engagement and defining the scope. The exam is a simulation of a real-world penetration test / vulnerability assessment where you need to report back to a fake customer. You will need to perform Open-Source Intelligence, hack into the external network and move laterally into the internal network and compromise the Domain Controller to complete the exam lab.As said the exam lab was setup like a real engagement would be and I really liked this type of exam. It is a good simulation of how a real penetration test might be.When the exam starts you are given five full days to hack into all the systems and an additional two days to write the report. For a beginner this should be plenty of time to finish the exam. The time given for the report writing could be a bit longer because it might be tough for beginners writing their first pentest report. I remember that it took me two full days to write my EWPT report for eLearnSecurity since it was my first ever penetration testing report and it took me quite some time. I would definitely recommend creating your own template in advance or using the one from TCM Security and definitely going through their example report.To pass the exam a student need to: Compromise the external and internal network Write a professional report Perform a live 15 minute debrief / presentationMy exam experiencesI started the exam at 9:30 in the morning and received my VPN pack a bit later. It took me 3 hours to complete my OSINT and get my initial access on the first machine. For some reason I always stress the first couple of hours of an exam and because of it I made an oopsie in the OSINT, which led me to not being able to get my initial access. After taking a small break and going back to the OSINT I saw my mistake, a typo -__- and did my attacks again and got access to the first machine.After gaining access to the first machine I owned one after the other and gained access to multiple machines within an hour. Getting to the DC took me the longest since I was looking for complicated AD stuff that wasn’t taught in the course. I took a break and did some basic enumeration and found the vector which led me to Domain Admin privileges.I completed the exam in 8 hours and started going through my notes and screenshots to double check if I had everything. After that I did some more enumeration in the environment and looked for other vulnerabilities to report. The exam is not about just owning all machines but about finding vulnerabilities to report to the ‘‘customer’’.After I was sure I got all my notes I got a good night of sleep and started writing the report. The writing of the report took me about 4-5 hours and I read through it again a couple hours later and the next day to turn it in. My report existed of 34 pages. After a couple of hours, I got the e-mail that I passed the reporting fase and that I could book a time for the debrief. Booking the time for the debrief was possible for the next day already, but since I didn’t have time that day I booked it two days later.I created a simple presentation for the debrief containing a summary of the different vulnerabilities found and explained the path of exploitation which lead to the compromise of the DC.Tips for the certifiation Prepare a template report and go through TCM security example report Check out my cheatsheets: Infrastructure: https://github.com/0xJs/RedTeaming_CheatSheet/tree/main/infrastructure Active Directory (CRTP) simplified version of the AD part in my redteaming cheatsheet: https://github.com/0xJs/CRTP-cheatsheet Take your time during the exam to sleep properly, take breaks, go for walks etc. Especially having a walk outside can really help when being stuck by going over what you have tried etc.Edit: If you liked the review and want to buy the PNPT exam, please use this affiliate link and ill get a small kickback.ConclusionI really liked the setup of the course and the exam environment. It simulates a real-life scenario penetration test and learns you the basics on how to perform one. It is the perfect course for beginners and I wish I was able to take it when I started my Ethical Hacking journey two years ago." }, { "title": "CRTO review", "url": "/posts/CRTO-review/", "categories": "Ethical Hacking, Reviews", "tags": "ethical hacking, red teaming", "date": "2022-04-17 20:57:00 +0200", "snippet": "IntroductionLast week I passed the Certified Red Team Operator (CRTO) exam. I have taken multiple courses about pentesting Active Directory (AD), this is the 6th lab and the 4th certification. The Active Directory part in the course is not very extensive, but the personal labs and overall experience were good. They weren’t slow or unstable like in eCPTX. The course mostly focusses on Red Teaming in a mostly Windows environment.You will get a personal lab with 40 hours of access which will only tick down the time the labs are running (you can freely stop and start them). It is recommended to take the course if you already have a basic understanding of Active Directory and its misconfigurations. By for example completing CRTP.The materialThe course has a focus on Red Teaming and will teach you about topics such as: What is red teaming and OPSEC Command and Control (The course teaches Cobalt Strike) Initial/host/domain reconnaissance Lateral movement Privilege escalation Pivoting Basic Active Directory abusesThe course with exam costs around 400 euros. A full curriculum can be found here. All the new thing I learned are added to my RedTeaming CheatSheet and I also made a Cobalt Strike page.The labsThe labs and the material go hand in hand and will guide you through the labs and the attack paths. You start with 40 hours of lab access and can always buy more time. I only used 20 hours of it because I tried to save as much time as possible by reading all the material and taking all my notes before diving into the lab. But this wasn’t neccesary since you have plenty of time to finish the lab.The lab didn’t teach me many new Active Directory concepts (I did CRTP, CRTE and eCPTX) but it did teach me how to do some attacks in different ways. One of the recently added things in the lab is Active Directory Certificate Services, which was new for me too. I also learned to be familiair with creating and using tickets instead of using Pass The Hash attacks for everything. Besides that I learned a lot about using Cobalt Strike and using the pivoting functionaility is amazing. It is way easier then doing everything manually! You can do one command and tunnel through multiple hops back to your teamserver, and even setup proxychains through all your agents! Its awesome!The lab also has a Kibana instance which collects all the logs where you would be able to detect your own attacks and create your own rules, but I didn’t play to much with it (yet, I will do this with the 20 hours left). The course inclused examples on how to detect all of the attacks.The lab is closed off and you won’t get a VPN to connect to the lab with our own machine. You will have to use the attacker kali and windows machine in the lab which you can access through Guacamole. You will be able to access any machine in the lab through it in case you need to troubleshoot something. There is a CRTO discord on the contact pageThe examWhen you book the exam, you are given some instructions already and it tells you about a threat profile which you need to emulate. Meaning you have to write your own cobalt strike profile to emulate the adversary their traffic etc. The exam has 8 flags which you need to collect, with a passing grade of 6 flags. The best tip comes from RastaMouse himself, which is crucial to pass the exam.You get 48 hours of exam access which can be split in-between 4 days, meaning you don’t have to stay up the full 48 hours stressing that if you go to sleep you might waste valuable time you needed to pass. You can sleep peacefully and take your breaks, cook food etc, which was a nice change! You can start and stop the exam just like the lab from SnapLabs, but stopping it also means all shells will die, unless you have built in some sort of persistence. The exam environment was stable and replicates a real-world environment. There is plenty of time to finish the exam within the 48 hours of access.The exam environment is like in the labs closed off and you will need to use the tools which are on the exam. They give you a attacker kali and windows machine as like the lab, but not all tools will be there. There is a post from RastaMouse explaining the why. You won’t have BloodHound for example, and some other tools I was familiar with.My exam experience10 minutes before my scheduled exam starting time my internet went down and I had to go to the office with my laptop to take the exam from there, which stressed me quite a bit. I was supposed to start at 9:30 but started around 10:30. In about 7 hours I had 6 flags which would mean I passed already, it was time to shutdown my laptop and to go home since the internet has been restored. Dammn what was I mad and stressed about my internet going down, luckily my Active Directory knowledge is strong which made me capture some flags quickly and that helped me lose the stress.After dinner I took my time to enumerate again and got access to the 7th flag. Then I went to bed and got the 8th flag after a good night of sleep. Two more days left and 32,5 more hours of exam lab time remaining. The abuses in the exam weren’t difficult except one.ConclusionI really liked the course and the lab, although the written material was bare sometimes. I would have liked to read more about Red Teaming and the Active Directory abuses and explanations could have been expended upon. I also missed a challange part in the lab where it wouldn’t take you through it and left you to figure it out on your own.Overall the course and the content was good and I hope RastaMouse created a advanced version." }, { "title": "eCPTXv2 review", "url": "/posts/eCPTXv2-review/", "categories": "Ethical Hacking, Reviews", "tags": "ethical hacking, red teaming", "date": "2022-04-14 18:57:00 +0200", "snippet": "IntroductionA while ago I passed the eLearn Security Certified Penetration Tester eXtreme (eCPTXv2) exam. I have taken multiple courses about pentesting Active Directory and have been learning a lot about it in the last two years. Which made me feel confident to take the course and the exam.The course is focussed on Red Teaming Active Directory and includes; Social engineering and Macro Development Active Directory Critical infrastructure such as SQL server, Exchange and WSUS Evasion techniquesThe materialA lot of the course was already well-known material for me since I took the CRTP and CRTE courses from Pentester Academy. eCPTXv2 covers all the techniques, but I think it lacked a bit in the domain enumeration part and using for example Bloodhound. Luckily CRTP covered this extensively and I recommend taking at least CRTP before attempting eCPTXv2. Overall the material was extensive and enough to prepare for the Active Directory attacks in the Exam. I won’t be able to tell if its a true Red Teaming course because I never did a Red Team before, but I think it’s a good step to get into Red Teaming. After the exam I bought the CRTO course and will take the exam soon, the CRTO course focuses a lot more on Red Teaming and OPSEC considerations, using Cobalt Strike as a C2.The labsThe course includes hundreds of slides and multiple labs were a lot of hours can be spent after reading all the course content. The labs include write-ups in case you are stuck. At the end of my learning journey the labs were down for multiple weeks. This was around February and they have fixed the labs since then. INE stated that broke their lab network while trying to upgrade to their new platform.The examThe exam wasn’t that hard, and I’m not sure it is because I prepared to well or already knew enough about Active Directory attacks. The exploitation in the exam wasn’t to complicated. I was stuck two times, but It didn’t took long till I figured out what to do. I expected the exam to be way harder. In total it took me around 30 hours to gain access to all the machines.There was one part in the exam the course won’t prepare you for which have been spoken about in multiple reviews, it’s a shame since its vital to pass the exam. It took eLearn Security only one day to review my report, which was a surprise since I have read in the unofficial discord it took almost the full 30 business days for other people. I guess they caught up on their backlog." } ]
